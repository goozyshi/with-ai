# 《Vue.js 设计与实现》拆解

> 对 **Vue 官方团队成员：霍春阳** 编写的 **《Vue.js 设计与实现》**精读、拆解

---

## 📚 第一篇 | [框架设计概览]

### 1.1 **权衡的艺术**

#### 📖 核心问题

❓ **这一章要解决什么问题？**

- 为什么 Vue 要选择声明式而不是命令式？
- 为什么 Vue 要选择虚拟 DOM 而不是 innerHTML？
- 为什么 Vue 要采用"运行时+编译时"而不是纯编译时/纯运行时？

💭 **我的理解**

**声明式选择的原因：**

- 命令式性能更好，声明式的代码可维护性更高
- Vue `内部封装命令式`实现，`对外提供声明式`
- 开发者只需关心结果而不是如何实现

**虚拟 DOM 选择的原因：**

- 性能排序：原生 DOM 操作 > 虚拟 DOM > innerHTML
- 可维护性排序：虚拟 DOM > innerHTML > 原生 DOM 操作
- 虚拟 DOM 在性能与可维护性之间找到最佳平衡点

**运行时+编译时选择的原因：**

- 纯编译时（如 Svelte）：性能理论最优，但缺乏运行时灵活性
- 纯运行时：灵活性最高，但无法做编译时优化
- 结合方案：既能`编译时分析优化，又保持运行时动态能力`

❓ **为什么需要这样设计？**

💭 **我的理解**

- 性能不是唯一目标，开发效率和维护成本同样重要
- 需要在理论最优和实际可用之间找平衡

❓ **如果 Vue 采用其他方案会有什么问题？**

💭 **我的理解**

**如果选择命令式（如原生 DOM 操作、jQuery 等）：**

- 代码复杂度激增，学习成本极高
- 维护困难，团队协作效率低
- 心智负担重，开发者需要关注实现细节而非业务逻辑

**如果选择 innerHTML：**

- 无法精准更新，每次都需要重建整个 DOM
- 无法支持组件化
- 跨平台受限(虚拟 DOM 可以抽象成对象)

**如果选择纯编译时：**

- 动态内容支持受限（无法处理运行时数据）
- 调试困难（编译后代码难读）

**如果选择纯运行时：**

- 无法分析用户提供的内容，编译时错误检查缺失
- 缺乏编译时优化空间（静态提升、预字符串化、Block 树等）
- 模板能力受限，要么性能差（运行时解析），要么心智负担高（纯 render 函数）

#### 🎯 关键概念

- **命令式 vs 声明式** ：

  - 命令式：告诉计算机"怎么做"，关注执行过程，像写菜谱的详细步骤
  - 声明式：告诉计算机"想要什么"，关注最终结果，像点菜只说菜名
  - Vue 选择声明式是为了降低心智负担，提升开发效率

- **虚拟 DOM 的选择**
  - 不是最快的方案，但是最平衡的方案
  - 提供了抽象层，支持跨平台和组件化
  - **允许框架做多层次优化：**
    - **编译时优化**：静态节点标记、动态节点收集、Block 树
    - **运行时优化**：diff 算法、批量更新、异步更新队列
    - **跨层优化**：编译时分析 + 运行时精准更新
- **运行时+编译时**
  - 编译时：template -> render 函数，做静态分析和优化
  - 运行时：执行 render 函数，处理动态逻辑
  - 两者结合：既有编译时优化，又有运行时灵活性

#### 🤔 质疑与思考

**问题 1：React 也用虚拟 DOM，Vue 和 React 的虚拟 DOM 有什么不同？**

- React：主要依靠虚拟 DOM diff，使用 Fiber 架构做时间切片
- Vue：结合响应式系统，能精确知道哪些组件需要更新
- 差异：Vue 的更新更精准，React 的并发能力更强

**问题 2：Svelte 的纯编译时方案真的不如 Vue 吗？**

- Svelte 优势：编译时优化彻底，`运行时体积小、首屏快`，性能理论最优
- Svelte 劣势：动态性受限，生态较小，复杂应用支持不足
- 适用场景：静态内容为主的网站 、高频小更新场景

**问题 3：在什么场景下，命令式代码比声明式更好？**

- 性能极致要求的场景（游戏、动画）
- 底层库开发（需要精确控制）
- 简单的 DOM 操作（不值得引入框架）

**问题 4：虚拟 DOM 相比直接 DOM 操作，在什么场景下优势最明显？**

- 频繁更新的复杂界面
- 数据频繁变化的表格、列表：框架自动 diff，精准更新，批量处理
- 组件化、状态管理复杂应用：
- 大量嵌套组件的页面
- 组件间状态共享和传递
- 组件的动态创建和销毁
- 跨平台需求

### 1.2 框架设计的核心要素

#### 📖 核心问题

❓ **这一章要解决什么问题？**

- 如何控制打包产物的体积？
- 如何提高框架的可维护性和用户体验？
- 如何处理框架中的错误？

💭 **我的理解**

**打包体积控制的必要性：**

- 打包体积直接影响页面加载速度和用户体验
- Vue 通过`环境变量、特性开关和 Tree-Shaking` 实现精确控制

**错误处理设计的价值**

- 统一的错误处理
- 集中收集错误便于调试和问题定位
- 区分`不同错误类型`有助于分类处理

**TypeScript 类型支持的重要性：**

- 提供了强大的类型检查，降低错误率
- 提供了更好的开发体验和 IDE 支持
- 类型定义本身也是一种文档

❓ **为什么需要这样设计？**

💭 **我的理解**

**打包体积控制：**

- Web 应用性能的关键在于资源加载速度
- 用户不应下载不需要使用的代码（如开发环境代码）
- 按需加载是现代前端框架的核心竞争力

**错误处理：**

- 框架内部错误如不统一处理、不明确会导致开发者体验差
- 统一接口便于开发者扩展错误处理（如上报、记录）

**关于类型系统：**

- 大型项目没有类型支持会导致维护困难
- IDE 智能提示依赖类型系统
- 类型是一种隐性文档，减少沟通成本

❓ **如果不这样做会怎样？**
💭 **我的理解**

**不控制打包体积：**

- 应用体积膨胀，加载时间延长， 用户体验变差
- 包含不必要代码（如开发警告）增加运行时开销

**不提供错误处理机制**

- 错误定位困难，开发效率低下
- 开发者需要自行处理各类错误，代码冗余

**不重视类型支持**

- 大型项目维护困难，重构风险高（靠人为约定而不是系统设计。）
- API 使用门槛提高，需要查阅更多文档
- 编辑器智能提示失效，开发效率降低

#### 🎯 关键概念

- **环境变量控制：**

  - Vue 使用`__DEV__`由*构建工具预定义*的环境变量区分开发/生产环境
  - 生产环境下自动移除所有开发警告代码

- **Tree-Shaking 优化**

  - Tree-Shaking 是一种静态分析技术，移除未使用的代码（dead code）
  - Vue 通过三种方式支持 Tree-Shaking：
    1. 使用 ES 模块（import/export）
    2. 导出独立函数而非默认导出对象
    3. 使用`/*#__PURE__*/`注释标记纯函数

- **特性开关和构建产物**

  - 特性开关可以仅包含使用到的功能，减少冗余代码
  - 按需加载
  - 可构建出多种不同用途的产物（完整版/运行时版/服务端版等）

- **错误处理**

  - Vue 提供 `app.config.errorHandler `全局配置， 所有内部错误通过`callWithErrorHandling`函数处理
  - 错误分类处理，包括：
    - 组件渲染错误
    - 生命周期钩子错误
    - 事件处理器错误
    - 侦听器错误
  - 提供错误上下文信息（组件名、钩子名等）
  - 集中处理所有类型错误，并支持自定义处理逻辑

  ```js
  let handleError = null
  export default {
    foo(fn) {
      callWithErrorHandling(fn)
    }
    // 用户可以调用该函数注册统一的错误处理函数
    registerErrorHandler(fn) {
      handleError = fn
    }
  }

  function callWithErrorHandling (fn) {
    try {
      fn && fn()
    } catch (e) {
      // 将捕获的错误传递给用户的错误处理程序
      handlerError(e)
    }
  }
  ```

- **TypeScript 支持**

  - Vue 3 完全支持使用 TypeScript 开发
  - 提供完整的类型定义和类型推导

#### 🤔 质疑与思考

**问题 1：为什么 Vue 要构建不同的打包产物？**

- 不同用户有不同需求，单一产物无法满足所有场景，用户可根据自身需求选择最适合的版本
  - 完整版（包含编译器）：适用于不使用构建工具的场景，可直接编译模板
  - 运行时版（不含编译器）：体积更小，适用于使用构建工具的场景
  - ESM 格式：支持 Tree-Shaking，适用于现代打包工具
  - IIFE/UMD 格式：适用于直接通过`<script>`标签使用的场景

**问题 2：callWithErrorHandling 接口可以捕获到所有错误吗？**

- 可以通过`try/catch`可以捕获到`运行时`以下类型的错误：
  - **组件渲染错误**：模板渲染过程中发生的错误
  - **生命周期钩子错误**：如 mounted, updated 等生命周期函数执行时的错误
  - **事件处理器错误**：用户交互事件处理函数中的错误（如 @click 绑定的处理函数）
  - **侦听器错误**：watch 和 computed 中发生的错误
- 不能捕获以下类型的错误：

  - **异步操作中的错误**：Promise 中的 reject、 setTimout、async/await
  - **非 Vue 管理的代码错误**：直接添加的 DOM 事件监听器 、第三方库
  - **网络请求错误：** Ajax/Fetch API 错误
  - **编译时错误：** 模板语法错误、TypeScript 类型错误

**问题 3：如何完善错误处理**

- window.onerror 和 unhandledrejection 事件处理异步错误
- 在关键异步操作中手动使用 try-catch 并调用错误处理器
- 使用 `errorCaptured` 生命周期钩子捕获特定组件树中的错误
- 采用第三方监控工具(如 Sentry)补充 Vue 的错误处理机制
