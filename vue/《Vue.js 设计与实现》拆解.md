# 《Vue.js 设计与实现》拆解

> **学习目标**：4D 深度学习拆解

---

## 📚 第一篇 | [框架设计概览]

### 1.1 **权衡的艺术**

#### 📖 核心问题

❓ **这一章要解决什么问题？**

- 为什么 Vue 要选择声明式而不是命令式？
- 为什么 Vue 要选择虚拟 DOM 而不是 innerHTML？
- 为什么 Vue 要采用"运行时+编译时"而不是纯编译时/纯运行时？

💭 **我的理解**
**声明式选择的原因：**

- 命令式性能更好，声明式的代码可维护性更高
- Vue `内部封装命令式`实现，`对外提供声明式`
- 开发者只需关心结果而不是如何实现

**虚拟 DOM 选择的原因：**

- 性能排序：原生 DOM 操作 > 虚拟 DOM > innerHTML
- 可维护性排序：虚拟 DOM > innerHTML > 原生 DOM 操作
- 虚拟 DOM 在性能与可维护性之间找到最佳平衡点

**运行时+编译时选择的原因：**

- 纯编译时（如 Svelte）：性能理论最优，但缺乏运行时灵活性
- 纯运行时：灵活性最高，但无法做编译时优化
- 结合方案：既能`编译时分析优化，又保持运行时动态能力`

❓ **为什么需要这样设计？**

💭 **我的理解**

- 性能不是唯一目标，开发效率和维护成本同样重要
- 需要在理论最优和实际可用之间找平衡

❓ **如果 Vue 采用其他方案会有什么问题？**

💭 **我的理解**

**如果选择命令式（如原生 DOM 操作、jQuery 等）：**

- 代码复杂度激增，学习成本极高
- 维护困难，团队协作效率低
- 心智负担重，开发者需要关注实现细节而非业务逻辑

**如果选择 innerHTML：**

- 无法精准更新，每次都需要重建整个 DOM
- 无法支持组件化
- 跨平台受限(虚拟 DOM 可以抽象成对象)

**如果选择纯编译时：**

- 动态内容支持受限（无法处理运行时数据）
- 调试困难（编译后代码难读）

**如果选择纯运行时：**

- 无法分析用户提供的内容，编译时错误检查缺失
- 缺乏编译时优化空间（静态提升、预字符串化、Block 树等）
- 模板能力受限，要么性能差（运行时解析），要么心智负担高（纯 render 函数）

#### 🎯 关键概念

- **命令式 vs 声明式** ：

  - 命令式：告诉计算机"怎么做"，关注执行过程，像写菜谱的详细步骤
  - 声明式：告诉计算机"想要什么"，关注最终结果，像点菜只说菜名
  - Vue 选择声明式是为了降低心智负担，提升开发效率

- **虚拟 DOM 的位置** - 在性能与维护性的平衡点

  - 不是最快的方案，但是最平衡的方案
  - 提供了抽象层，支持跨平台和组件化
  - **允许框架做多层次优化：**
    - **编译时优化**：静态节点标记、动态节点收集、Block 树
    - **运行时优化**：diff 算法、批量更新、异步更新队列
    - **跨层优化**：编译时分析 + 运行时精准更新

- **运行时+编译时** - 灵活性与性能的最佳结合
  - 编译时：template -> render 函数，做静态分析和优化
  - 运行时：执行 render 函数，处理动态逻辑
  - 两者结合：既有编译时优化，又有运行时灵活性

#### 🤔 质疑与思考

- **React 也用虚拟 DOM，Vue 和 React 的虚拟 DOM 有什么不同？**

  - React：主要依靠虚拟 DOM diff，使用 Fiber 架构做时间切片
  - Vue：结合响应式系统，能精确知道哪些组件需要更新
  - 差异：Vue 的更新更精准，React 的并发能力更强

- **Svelte 的纯编译时方案真的不如 Vue 吗？**

  - Svelte 优势：编译时优化彻底，运行时体积小，性能理论最优
  - Svelte 劣势：动态性受限，生态较小，复杂应用支持不足
  - 适用场景：Svelte 适合简单应用，Vue 适合复杂应用

- **在什么场景下，命令式代码比声明式更好？**

  - 性能极致要求的场景（游戏、动画）
  - 底层库开发（需要精确控制）
  - 简单的 DOM 操作（不值得引入框架）

- **虚拟 DOM 相比直接 DOM 操作，在什么场景下优势最明显？**
- 频繁更新的复杂界面
  - 数据频繁变化的表格、列表：框架自动 diff，精准更新，批量处理
- 组件化、状态管理复杂应用：
  - 大量嵌套组件的页面
  - 组件间状态共享和传递
  - 组件的动态创建和销毁
- 跨平台需求
